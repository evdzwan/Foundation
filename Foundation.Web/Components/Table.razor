@attribute [CascadingTypeParameter(nameof(TItem))]
@inject PersistentComponentState State
@implements IDisposable
@typeparam TItem

<div class="table">
    <CascadingValue Value="this" IsFixed>
        @Columns
    </CascadingValue>

    <Defer>
        <ForEach Items="RegisteredColumns" Context="column">
            <div class="table-column" @key="column" />
        </ForEach>

        <div class="table-header">
            <ForEach Items="RegisteredColumns" Context="column">
                <div class="table-cell" @key="column">
                    @column.Header
                </div>
            </ForEach>
        </div>

        <div class="table-body">
            @if (ItemsInView is { Length: > 0 } itemsInView)
            {
                <ForEach Items="itemsInView" Context="item">
                    <div class="table-row" @key="item">
                        <ForEach Items="RegisteredColumns" Context="column">
                            <div class="table-cell" @key="column">
                                @column.Cell?.Invoke(item)
                            </div>
                        </ForEach>
                    </div>
                </ForEach>
            }
            else if (ItemsInView is { Length: 0 })
            {
                <div class="table-row empty">@Empty</div>
            }
            else
            {
                <div class="table-row loading">@Loading</div>
            }
        </div>
    </Defer>
</div>

@code {
    readonly List<TableColumn<TItem>> RegisteredColumns = [];
    const int PageSize = 10;

    TItem[]? ItemsInView;
    PersistingComponentStateSubscription ItemsInViewSubscription;

    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public RenderFragment? Columns { get; set; }
    [Parameter] public RenderFragment? Empty { get; set; }
    [Parameter] public RenderFragment? Loading { get; set; }
    [Parameter, EditorRequired] public required IAsyncCollection<TItem> Items { get; set; }

    protected override void OnInitialized()
    {
        if (State.TryTakeFromJson(nameof(ItemsInView), out TItem[]? itemsInView))
        {
            ItemsInView = itemsInView;
        }

        ItemsInViewSubscription = State.RegisterOnPersisting(PersistFirstPage);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ItemsInView is null)
        {
            ItemsInView = State.TryTakeFromJson(nameof(ItemsInView), out TItem[]? itemsInView) ? itemsInView : await GetPage(page: 0);
            StateHasChanged();
        }
    }

    protected override void OnParametersSet()
    {
        Columns ??= ChildContent;
        Empty ??= @<span>No data available</span>;
        Loading ??= @<span>Loading...</span>;
    }

    ITask<TItem[]> GetPage(int page)
        => Items.GetView(new(Skip: page * PageSize, Take: PageSize));

    async Task PersistFirstPage()
    {
        var itemsInView = await GetPage(page: 0);
        State.PersistAsJson(nameof(ItemsInView), itemsInView);
    }

    void IDisposable.Dispose()
        => ItemsInViewSubscription.Dispose();

    internal void AddColumn(TableColumn<TItem> column) => RegisteredColumns.Add(column);
    internal void RemoveColumn(TableColumn<TItem> column) => RegisteredColumns.Remove(column);
}
